<html>
<header>
	<style>
		canvas {
			width: 600px;
			height: 600px;
			position: absolute;
			left: 50%;
			top: 50%;
			transform: translateX(-50%) translateY(-50%);
			background-image: url('chess.jpeg');
		}
	</style>
</header>
<body>
	<canvas onmousedown="draw(event)" id="canvas" width="1200" height="1200">	
	</canvas>
	<script type="text/javascript">
		let over = false
		let player1 = []
		let player2 = []
		let turn = 'black'
		let width = 600
		let lineNum = 19
		let padding = width / lineNum / 2

		function drawBoard () {
			let element = document.getElementById('canvas')
			let cxt = element.getContext('2d')
			cxt.clearRect(0, 0, element.width, element.height)

			cxt.scale(2, 2)
			cxt.strokeStyle = '#000'
			cxt.lineWidth = 1

			let start = padding
			for (let i = 0; i <= lineNum; i++) {
				cxt.beginPath()
				cxt.moveTo(start, padding)
				cxt.lineTo(start, width - padding)
				cxt.stroke()

				cxt.beginPath()
				cxt.moveTo(padding, start)
				cxt.lineTo(width - padding, start)
				cxt.stroke()

				start = (i + 1) * (width / lineNum) + padding
			}
		}

		function getStyles (obj) { //兼容FF，IE10; IE9及以下未测试
			return document.defaultView.getComputedStyle(obj)
		}

		function getCanvasPos (canvas, e) { //获取鼠标在canvas上的坐标  
		    var rect = canvas.getBoundingClientRect()
		    var leftB = parseInt(getStyles(canvas).borderLeftWidth)//获取的是样式，需要转换为数值
		    var topB = parseInt(getStyles(canvas).borderTopWidth)
		    return {   
			    x: (e.clientX - rect.left) - leftB,  
			    y: (e.clientY - rect.top) - topB 
			}
		}

		function checkPlaceholder (indexX, indexY) {
			let arr1 = player1.slice(0)
			let arr2 = player2.slice(0)
			let arr = arr1.concat(arr2)
			for (let i in arr) {
				let item = arr[i]
				if (item[2] === indexX && item[3] === indexY) {
					return false
				}
			}

			return true
		}

		function checkWin (turn) {
			let player = turn === 'black' ? player2.slice(0) : player1.slice(0)
			let lastPoint = player[player.length - 1]

			
			let leftNum = 0
			let rightNum = 0

			let upNum = 0
			let downNum = 0

			let leftUpNum = 0
			let rightDownNum = 0

			let leftDownNum = 0
			let rightUpNum = 0

			for (let n = 0; n < 4; n++) {
				for (let i = 0; i <= player.length - 2; i++) {
					let item = player[i]
					// 横线赢算法
					if (lastPoint[2] - n - 1 == item[2] && lastPoint[3] === item[3]) {
						leftNum++
					}
					if (lastPoint[2] + n + 1 == item[2] && lastPoint[3] === item[3]) {
						rightNum++
					}
					// 竖线赢算法
					if (lastPoint[2] === item[2] && lastPoint[3] - n - 1 == item[3]) {
						upNum++
					}
					if (lastPoint[2] === item[2] && lastPoint[3] + n + 1 == item[3]) {
						downNum++
					}
					// 正斜线算法
					if (lastPoint[2] - n - 1  == item[2] && lastPoint[3] - n - 1 == item[3]) {
						leftUpNum++
					}
					if (lastPoint[2] + n + 1  == item[2] && lastPoint[3] + n + 1 == item[3]) {
						rightDownNum++
					}
					// 反斜线算法
					if (lastPoint[2] - n - 1  == item[2] && lastPoint[3] + n + 1 == item[3]) {
						leftDownNum++
					}
					if (lastPoint[2] + n + 1  == item[2] && lastPoint[3] - n - 1 == item[3]) {
						rightUpNum++
					}
				}

			}
			if (leftNum + rightNum >= 4 || upNum + downNum >= 4 || leftUpNum + rightDownNum >= 4 || leftDownNum + rightUpNum >= 4) {
				return true
			}
			return false
		}

		function draw (e) {
			if (over) {
				return
			}
		    var c = document.getElementById('canvas')

		    let pos = getCanvasPos(c, e)
		    let nearlyPoint = getNearlyPoint(pos.x, pos.y)
		    // console.log(nearlyPoint[0], nearlyPoint[1])
		    let chessX = nearlyPoint[0]
		    let chessY = nearlyPoint[1]
		    if (checkPlaceholder(nearlyPoint[2], nearlyPoint[3]) && chessX && chessY) {
		    	gogo(chessX, chessY, turn)
			    if (turn === 'black') {
			    	player1.push(nearlyPoint)
			    	turn = 'white'
			    } else {
			    	player2.push(nearlyPoint)
			    	turn = 'black'
			    }

			    if (checkWin(turn)) {
			    	console.log(`${turn === 'black' ? 'white' : 'black'} Win`)
			    	over = true
			    }
		    }
		}

		function getNearlyPoint (x, y) {
			let returnX, indexX, returnY, indexY
			for (let i = 0; i <= lineNum; i++) {
				let v = (i * (width / lineNum) + padding).toFixed(3)
				let v1 = ((i + 1) * (width / lineNum) + padding).toFixed(3)

				if (x >= v && x <= v1) {
					if (x - v < (width / lineNum + padding) / 3) {
						returnX = v
						indexX = i + 1
					} else {
						returnX = v1
						indexX = i + 2
					}
				}

				if (y >= v && y <= v1) {
					if (y - v < (width / lineNum + padding) / 3) {
						returnY = v
						indexY = i + 1
					} else {
						returnY = v1
						indexY = i + 2
					}
				}

				if (returnX && returnY) {
					break
				}
			}
			return [returnX, returnY, indexX, indexY]
		}

		function gogo (x, y, chessType) {
			let c = document.getElementById('canvas')
			let cxt = c.getContext('2d')

		    cxt.beginPath()
		    cxt.arc(x, y, padding, 0, Math.PI * 2, true)
		    cxt.closePath()

		    let grd = cxt.createRadialGradient(x - 1, y, padding, x + 3, y - 3, padding / 20)
		    if (chessType === 'black') {
		    	grd.addColorStop(0, 'black')
				grd.addColorStop(1, 'white')
		    } else {
		    	grd.addColorStop(0, '#d1d1d1')
				grd.addColorStop(1, '#f9f9f9')
		    }

			cxt.fillStyle = grd
			cxt.fill()
		}

		function ai () {

		}

		drawBoard()
	</script>
</body>
</html>